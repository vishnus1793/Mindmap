{
  "scraped_content": {
    "url": "https://nodejs.org/docs/latest/api/assert.html",
    "title": "Assert | Node.js v24.6.0 Documentation",
    "sections": [
      {
        "title": "Assert#",
        "content": "Source Code: lib/assert.js The node:assert module provides a set of assertion functions for verifying\ninvariants. ",
        "keywords": []
      },
      {
        "title": "Strict assertion mode#",
        "content": "Exposed as require('node:assert/strict'). Changed \"strict mode\" to \"strict assertion mode\" and \"legacy mode\" to \"legacy assertion mode\" to avoid confusion with the more usual meaning of \"strict mode\". Added error diffs to the strict assertion mode. Added strict assertion mode to the assert module. Added in: v9.9.0 In strict assertion mode, non-strict methods behave like their corresponding\nstrict methods. For example, assert.deepEqual() will behave like\nassert.deepStrictEqual(). In strict assertion mode, error messages for objects display a diff. In legacy\nassertion mode, error messages for objects display the objects, often truncated. To use strict assertion mode: Example error diff: To deactivate the colors, use the NO_COLOR or NODE_DISABLE_COLORS\nenvironment variables. This will also deactivate the colors in the REPL. For\nmore on color support in terminal environments, read the tty\ngetColorDepth() documentation. ",
        "keywords": []
      },
      {
        "title": "Legacy assertion mode#",
        "content": "Legacy assertion mode uses the == operator in: To use legacy assertion mode: Legacy assertion mode may have surprising results, especially when using\nassert.deepEqual(): ",
        "keywords": []
      },
      {
        "title": "Class: assert.AssertionError#",
        "content": "Indicates the failure of an assertion. All errors thrown by the node:assert\nmodule will be instances of the AssertionError class. ",
        "keywords": []
      },
      {
        "title": "new assert.AssertionError(options)#",
        "content": "A subclass of <Error> that indicates the failure of an assertion. All instances contain the built-in Error properties (message and name)\nand: ",
        "keywords": []
      },
      {
        "title": "Class: assert.Assert#",
        "content": "The Assert class allows creating independent assertion instances with custom options. ",
        "keywords": []
      },
      {
        "title": "new assert.Assert([options])#",
        "content": "Creates a new assertion instance. The diff option controls the verbosity of diffs in assertion error messages. Important: When destructuring assertion methods from an Assert instance,\nthe methods lose their connection to the instance's configuration options (such as diff and strict settings).\nThe destructured methods will fall back to default behavior instead. When destructured, methods lose access to the instance's this context and revert to default assertion behavior\n(diff: 'simple', non-strict mode).\nTo maintain custom options when using destructured methods, avoid\ndestructuring and call methods directly on the instance. ",
        "keywords": []
      },
      {
        "title": "Class: assert.CallTracker#",
        "content": "the assert.CallTracker class has been deprecated and will be removed in a future version. Added in: v14.2.0, v12.19.0 This feature is deprecated and will be removed in a future version.\nPlease consider using alternatives such as the\nmock helper function. ",
        "keywords": []
      },
      {
        "title": "new assert.CallTracker()#",
        "content": "Creates a new CallTracker object which can be used to track if functions\nwere called a specific number of times. The tracker.verify() must be called\nfor the verification to take place. The usual pattern would be to call it in a\nprocess.on('exit') handler. ",
        "keywords": []
      },
      {
        "title": "tracker.calls([fn][, exact])#",
        "content": "The wrapper function is expected to be called exactly exact times. If the\nfunction has not been called exactly exact times when\ntracker.verify() is called, then tracker.verify() will throw an\nerror. ",
        "keywords": []
      },
      {
        "title": "tracker.getCalls(fn)#",
        "content": "fn <Function> Returns: <Array> An array with all the calls to a tracked function. Object <Object> ",
        "keywords": []
      },
      {
        "title": "tracker.report()#",
        "content": "The arrays contains information about the expected and actual number of calls of\nthe functions that have not been called the expected number of times. ",
        "keywords": []
      },
      {
        "title": "tracker.reset([fn])#",
        "content": "Reset calls of the call tracker.\nIf a tracked function is passed as an argument, the calls will be reset for it.\nIf no arguments are passed, all tracked functions will be reset. ",
        "keywords": []
      },
      {
        "title": "tracker.verify()#",
        "content": "Iterates through the list of functions passed to\ntracker.calls() and will throw an error for functions that\nhave not been called the expected number of times. ",
        "keywords": []
      },
      {
        "title": "assert(value[, message])#",
        "content": "An alias of assert.ok(). ",
        "keywords": []
      },
      {
        "title": "assert.deepEqual(actual, expected[, message])#",
        "content": "Recursion now stops when either side encounters a circular reference. Error cause and errors properties are now compared as well. Regular expressions lastIndex property is now compared as well. In Legacy assertion mode, changed status from Deprecated to Legacy. NaN is now treated as being identical if both sides are NaN. The type tags are now properly compared and there are a couple minor comparison adjustments to make the check less surprising. The Error names and messages are now properly compared. The Set and Map content is also compared. Typed array slices are handled correctly now. Objects with circular references can be used as inputs now. Handle non-Uint8Array typed arrays correctly. Added in: v0.1.21 Strict assertion mode An alias of assert.deepStrictEqual(). Legacy assertion mode Tests for deep equality between the actual and expected parameters. Consider\nusing assert.deepStrictEqual() instead. assert.deepEqual() can have\nsurprising results. Deep equality means that the enumerable \"own\" properties of child objects\nare also recursively evaluated by the following rules. ",
        "keywords": []
      },
      {
        "title": "Comparison details#",
        "content": "The following example does not throw an AssertionError because the\nprimitives are compared using the == operator. \"Deep\" equality means that the enumerable \"own\" properties of child objects\nare evaluated also: If the values are not equal, an AssertionError is thrown with a message\nproperty set equal to the value of the message parameter. If the message\nparameter is undefined, a default error message is assigned. If the message\nparameter is an instance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.deepStrictEqual(actual, expected[, message])#",
        "content": "Recursion now stops when either side encounters a circular reference. Error cause and errors properties are now compared as well. Regular expressions lastIndex property is now compared as well. Enumerable symbol properties are now compared. The NaN is now compared using the SameValueZero comparison. The Error names and messages are now properly compared. The Set and Map content is also compared. Objects with circular references can be used as inputs now. Typed array slices are handled correctly now. Handle non-Uint8Array typed arrays correctly. Added in: v1.2.0 Tests for deep equality between the actual and expected parameters.\n\"Deep\" equality means that the enumerable \"own\" properties of child objects\nare recursively evaluated also by the following rules. ",
        "keywords": []
      },
      {
        "title": "Comparison details#",
        "content": "If the values are not equal, an AssertionError is thrown with a message\nproperty set equal to the value of the message parameter. If the message\nparameter is undefined, a default error message is assigned. If the message\nparameter is an instance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.doesNotMatch(string, regexp[, message])#",
        "content": "This API is no longer experimental. Added in: v13.6.0, v12.16.0 Expects the string input not to match the regular expression. If the values do match, or if the string argument is of another type than\nstring, an AssertionError is thrown with a message property set equal\nto the value of the message parameter. If the message parameter is\nundefined, a default error message is assigned. If the message parameter is an\ninstance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.doesNotReject(asyncFn[, error][, message])#",
        "content": "Awaits the asyncFn promise or, if asyncFn is a function, immediately\ncalls the function and awaits the returned promise to complete. It will then\ncheck that the promise is not rejected. If asyncFn is a function and it throws an error synchronously,\nassert.doesNotReject() will return a rejected Promise with that error. If\nthe function does not return a promise, assert.doesNotReject() will return a\nrejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases\nthe error handler is skipped. Using assert.doesNotReject() is actually not useful because there is little\nbenefit in catching a rejection and then rejecting it again. Instead, consider\nadding a comment next to the specific code path that should not reject and keep\nerror messages as expressive as possible. If specified, error can be a Class, <RegExp> or a validation\nfunction. See assert.throws() for more details. Besides the async nature to await the completion behaves identically to\nassert.doesNotThrow(). ",
        "keywords": []
      },
      {
        "title": "assert.doesNotThrow(fn[, error][, message])#",
        "content": "The message parameter is respected now. The error parameter can now be an arrow function. Added in: v0.1.21 Asserts that the function fn does not throw an error. Using assert.doesNotThrow() is actually not useful because there\nis no benefit in catching an error and then rethrowing it. Instead, consider\nadding a comment next to the specific code path that should not throw and keep\nerror messages as expressive as possible. When assert.doesNotThrow() is called, it will immediately call the fn\nfunction. If an error is thrown and it is the same type as that specified by the error\nparameter, then an AssertionError is thrown. If the error is of a\ndifferent type, or if the error parameter is undefined, the error is\npropagated back to the caller. If specified, error can be a Class, <RegExp>, or a validation\nfunction. See assert.throws() for more details. The following, for instance, will throw the <TypeError> because there is no\nmatching error type in the assertion: However, the following will result in an AssertionError with the message\n'Got unwanted exception...': If an AssertionError is thrown and a value is provided for the message\nparameter, the value of message will be appended to the AssertionError\nmessage: ",
        "keywords": []
      },
      {
        "title": "assert.equal(actual, expected[, message])#",
        "content": "In Legacy assertion mode, changed status from Deprecated to Legacy. NaN is now treated as being identical if both sides are NaN. Added in: v0.1.21 Strict assertion mode An alias of assert.strictEqual(). Legacy assertion mode Tests shallow, coercive equality between the actual and expected parameters\nusing the == operator. NaN is specially handled\nand treated as being identical if both sides are NaN. If the values are not equal, an AssertionError is thrown with a message\nproperty set equal to the value of the message parameter. If the message\nparameter is undefined, a default error message is assigned. If the message\nparameter is an instance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.fail([message])#",
        "content": "Throws an AssertionError with the provided error message or a default\nerror message. If the message parameter is an instance of <Error> then\nit will be thrown instead of the AssertionError. Using assert.fail() with more than two arguments is possible but deprecated.\nSee below for further details. ",
        "keywords": []
      },
      {
        "title": "assert.fail(actual, expected[, message[, operator[, stackStartFn]]])#",
        "content": "Calling assert.fail() with more than one argument is deprecated and emits a warning. Added in: v0.1.21 If message is falsy, the error message is set as the values of actual and\nexpected separated by the provided operator. If just the two actual and\nexpected arguments are provided, operator will default to '!='. If\nmessage is provided as third argument it will be used as the error message and\nthe other arguments will be stored as properties on the thrown object. If\nstackStartFn is provided, all stack frames above that function will be\nremoved from stacktrace (see Error.captureStackTrace). If no arguments are\ngiven, the default message Failed will be used. In the last three cases actual, expected, and operator have no\ninfluence on the error message. Example use of stackStartFn for truncating the exception's stacktrace: ",
        "keywords": []
      },
      {
        "title": "assert.ifError(value)#",
        "content": "Instead of throwing the original error it is now wrapped into an [AssertionError][] that contains the full stack trace. Value may now only be undefined or null. Before all falsy values were handled the same as null and did not throw. Added in: v0.1.97 Throws value if value is not undefined or null. This is useful when\ntesting the error argument in callbacks. The stack trace contains all frames\nfrom the error passed to ifError() including the potential new frames for\nifError() itself. ",
        "keywords": []
      },
      {
        "title": "assert.match(string, regexp[, message])#",
        "content": "This API is no longer experimental. Added in: v13.6.0, v12.16.0 Expects the string input to match the regular expression. If the values do not match, or if the string argument is of another type than\nstring, an AssertionError is thrown with a message property set equal\nto the value of the message parameter. If the message parameter is\nundefined, a default error message is assigned. If the message parameter is an\ninstance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.notDeepEqual(actual, expected[, message])#",
        "content": "In Legacy assertion mode, changed status from Deprecated to Legacy. NaN is now treated as being identical if both sides are NaN. The Error names and messages are now properly compared. The Set and Map content is also compared. Typed array slices are handled correctly now. Objects with circular references can be used as inputs now. Handle non-Uint8Array typed arrays correctly. Added in: v0.1.21 Strict assertion mode An alias of assert.notDeepStrictEqual(). Legacy assertion mode Tests for any deep inequality. Opposite of assert.deepEqual(). If the values are deeply equal, an AssertionError is thrown with a\nmessage property set equal to the value of the message parameter. If the\nmessage parameter is undefined, a default error message is assigned. If the\nmessage parameter is an instance of <Error> then it will be thrown\ninstead of the AssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.notDeepStrictEqual(actual, expected[, message])#",
        "content": "The -0 and +0 are not considered equal anymore. The NaN is now compared using the SameValueZero comparison. The Error names and messages are now properly compared. The Set and Map content is also compared. Objects with circular references can be used as inputs now. Typed array slices are handled correctly now. Handle non-Uint8Array typed arrays correctly. Added in: v1.2.0 Tests for deep strict inequality. Opposite of assert.deepStrictEqual(). If the values are deeply and strictly equal, an AssertionError is thrown\nwith a message property set equal to the value of the message parameter. If\nthe message parameter is undefined, a default error message is assigned. If\nthe message parameter is an instance of <Error> then it will be thrown\ninstead of the AssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.notEqual(actual, expected[, message])#",
        "content": "In Legacy assertion mode, changed status from Deprecated to Legacy. NaN is now treated as being identical if both sides are NaN. Added in: v0.1.21 Strict assertion mode An alias of assert.notStrictEqual(). Legacy assertion mode Tests shallow, coercive inequality with the != operator. NaN is\nspecially handled and treated as being identical if both sides are NaN. If the values are equal, an AssertionError is thrown with a message\nproperty set equal to the value of the message parameter. If the message\nparameter is undefined, a default error message is assigned. If the message\nparameter is an instance of <Error> then it will be thrown instead of the\nAssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.notStrictEqual(actual, expected[, message])#",
        "content": "Used comparison changed from Strict Equality to Object.is(). Added in: v0.1.21 Tests strict inequality between the actual and expected parameters as\ndetermined by Object.is(). If the values are strictly equal, an AssertionError is thrown with a\nmessage property set equal to the value of the message parameter. If the\nmessage parameter is undefined, a default error message is assigned. If the\nmessage parameter is an instance of <Error> then it will be thrown\ninstead of the AssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.ok(value[, message])#",
        "content": "The assert.ok() (no arguments) will now use a predefined error message. Added in: v0.1.21 Tests if value is truthy. It is equivalent to\nassert.equal(!!value, true, message). If value is not truthy, an AssertionError is thrown with a message\nproperty set equal to the value of the message parameter. If the message\nparameter is undefined, a default error message is assigned. If the message\nparameter is an instance of <Error> then it will be thrown instead of the\nAssertionError.\nIf no arguments are passed in at all message will be set to the string:\n'No value argument passed to `assert.ok()`'. Be aware that in the repl the error message will be different to the one\nthrown in a file! See below for further details. ",
        "keywords": []
      },
      {
        "title": "assert.rejects(asyncFn[, error][, message])#",
        "content": "Awaits the asyncFn promise or, if asyncFn is a function, immediately\ncalls the function and awaits the returned promise to complete. It will then\ncheck that the promise is rejected. If asyncFn is a function and it throws an error synchronously,\nassert.rejects() will return a rejected Promise with that error. If the\nfunction does not return a promise, assert.rejects() will return a rejected\nPromise with an ERR_INVALID_RETURN_VALUE error. In both cases the error\nhandler is skipped. Besides the async nature to await the completion behaves identically to\nassert.throws(). If specified, error can be a Class, <RegExp>, a validation function,\nan object where each property will be tested for, or an instance of error where\neach property will be tested for including the non-enumerable message and\nname properties. If specified, message will be the message provided by the AssertionError\nif the asyncFn fails to reject. error cannot be a string. If a string is provided as the second\nargument, then error is assumed to be omitted and the string will be used for\nmessage instead. This can lead to easy-to-miss mistakes. Please read the\nexample in assert.throws() carefully if using a string as the second\nargument gets considered. ",
        "keywords": []
      },
      {
        "title": "assert.strictEqual(actual, expected[, message])#",
        "content": "Used comparison changed from Strict Equality to Object.is(). Added in: v0.1.21 Tests strict equality between the actual and expected parameters as\ndetermined by Object.is(). If the values are not strictly equal, an AssertionError is thrown with a\nmessage property set equal to the value of the message parameter. If the\nmessage parameter is undefined, a default error message is assigned. If the\nmessage parameter is an instance of <Error> then it will be thrown\ninstead of the AssertionError. ",
        "keywords": []
      },
      {
        "title": "assert.throws(fn[, error][, message])#",
        "content": "The error parameter can be an object containing regular expressions now. The error parameter can now be an object as well. The error parameter can now be an arrow function. Added in: v0.1.21 Expects the function fn to throw an error. If specified, error can be a Class, <RegExp>, a validation function,\na validation object where each property will be tested for strict deep equality,\nor an instance of error where each property will be tested for strict deep\nequality including the non-enumerable message and name properties. When\nusing an object, it is also possible to use a regular expression, when\nvalidating against a string property. See below for examples. If specified, message will be appended to the message provided by the\nAssertionError if the fn call fails to throw or in case the error validation\nfails. Custom validation object/error instance: Validate instanceof using constructor: Validate error message using <RegExp>: Using a regular expression runs .toString on the error object, and will\ntherefore also include the error name. Custom error validation: The function must return true to indicate all internal validations passed.\nIt will otherwise fail with an AssertionError. error cannot be a string. If a string is provided as the second\nargument, then error is assumed to be omitted and the string will be used for\nmessage instead. This can lead to easy-to-miss mistakes. Using the same\nmessage as the thrown error message is going to result in an\nERR_AMBIGUOUS_ARGUMENT error. Please read the example below carefully if using\na string as the second argument gets considered: Due to the confusing error-prone notation, avoid a string as the second\nargument. ",
        "keywords": []
      },
      {
        "title": "assert.partialDeepStrictEqual(actual, expected[, message])#",
        "content": "partialDeepStrictEqual is now Stable. Previously, it had been Experimental. Added in: v23.4.0, v22.13.0 Tests for partial deep equality between the actual and expected parameters.\n\"Deep\" equality means that the enumerable \"own\" properties of child objects\nare recursively evaluated also by the following rules. \"Partial\" equality means\nthat only properties that exist on the expected parameter are going to be\ncompared. This method always passes the same test cases as assert.deepStrictEqual(),\nbehaving as a super set of it. ",
        "keywords": []
      }
    ],
    "full_text": "Assert | Node.js v24.6.0 Documentation Skip to content Node.js About this documentation Usage and example Assertion testing Asynchronous context tracking Async hooks Buffer C++ addons C/C++ addons with Node-API C++ embedder API Child processes Cluster Command-line options Console Crypto Debugger Deprecated APIs Diagnostics Channel DNS Domain Environment Variables Errors Events File system Globals HTTP HTTP/2 HTTPS Inspector Internationalization Modules: CommonJS modules Modules: ECMAScript modules Modules: node:module API Modules: Packages Modules: TypeScript Net OS Path Performance hooks Permissions Process Punycode Query strings Readline REPL Report Single executable applications SQLite Stream String decoder Test runner Timers TLS/SSL Trace events TTY UDP/datagram URL Utilities V8 VM WASI Web Crypto API Web Streams API Worker threads Zlib Code repository and issue tracker Table of contents Assert Strict assertion mode Legacy assertion mode Class: assert.AssertionError new assert.AssertionError(options) Class: assert.Assert new assert.Assert([options]) Class: assert.CallTracker new assert.CallTracker() tracker.calls([fn][, exact]) tracker.getCalls(fn) tracker.report() tracker.reset([fn]) tracker.verify() assert(value[, message]) assert.deepEqual(actual, expected[, message]) Comparison details assert.deepStrictEqual(actual, expected[, message]) Comparison details assert.doesNotMatch(string, regexp[, message]) assert.doesNotReject(asyncFn[, error][, message]) assert.doesNotThrow(fn[, error][, message]) assert.equal(actual, expected[, message]) assert.fail([message]) assert.fail(actual, expected[, message[, operator[, stackStartFn]]]) assert.ifError(value) assert.match(string, regexp[, message]) assert.notDeepEqual(actual, expected[, message]) assert.notDeepStrictEqual(actual, expected[, message]) assert.notEqual(actual, expected[, message]) assert.notStrictEqual(actual, expected[, message]) assert.ok(value[, message]) assert.rejects(asyncFn[, error][, message]) assert.strictEqual(actual, expected[, message]) assert.throws(fn[, error][, message]) assert.partialDeepStrictEqual(actual, expected[, message]) Comparison details Assert# Stability: 2 - Stable Source Code: lib/assert.js The node:assert module provides a set of assertion functions for verifying invariants. Strict assertion mode# History VersionChanges v15.0.0 Exposed as require('node:assert/strict'). v13.9.0, v12.16.2 Changed \"strict mode\" to \"strict assertion mode\" and \"legacy mode\" to \"legacy assertion mode\" to avoid confusion with the more usual meaning of \"strict mode\". v9.9.0 Added error diffs to the strict assertion mode. v9.9.0 Added strict assertion mode to the assert module. v9.9.0 Added in: v9.9.0 In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example, assert.deepEqual() will behave like assert.deepStrictEqual(). In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error messages for objects display the objects, often truncated. To use strict assertion mode: import { strict as assert } from 'node:assert';const assert = require('node:assert').strict;copy import assert from 'node:assert/strict';const assert = require('node:assert/strict');copy Example error diff: import { strict as assert } from 'node:assert'; assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected ... Lines skipped // // [ // [ // ... // 2, // + 3 // - '3' // ], // ... // 5 // ]const assert = require('node:assert/strict'); assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected ... Lines skipped // // [ // [ // ... // 2, // + 3 // - '3' // ], // ... // 5 // ]copy To deactivate the colors, use the NO_COLOR or NODE_DISABLE_COLORS environment variables. This will also deactivate the colors in the REPL. For more on color support in terminal environments, read the tty getColorDepth() documentation. Legacy assertion mode# Legacy assertion mode uses the == operator in: assert.deepEqual() assert.equal() assert.notDeepEqual() assert.notEqual() To use legacy assertion mode: import assert from 'node:assert';const assert = require('node:assert');copy Legacy assertion mode may have surprising results, especially when using assert.deepEqual(): // WARNING: This does not throw an AssertionError in legacy assertion mode! assert.deepEqual(/a/gi, new Date()); copy Class: assert.AssertionError# Extends: <errors.Error> Indicates the failure of an assertion. All errors thrown by the node:assert module will be instances of the AssertionError class. new assert.AssertionError(options)# Added in: v0.1.21 options <Object> message <string> If provided, the error message is set to this value. actual <any> The actual property on the error instance. expected <any> The expected property on the error instance. operator <string> The operator property on the error instance. stackStartFn <Function> If provided, the generated stack trace omits frames before this function. diff <string> If set to 'full', shows the full diff in assertion errors. Defaults to 'simple'. Accepted values: 'simple', 'full'. A subclass of <Error> that indicates the failure of an assertion. All instances contain the built-in Error properties (message and name) and: actual <any> Set to the actual argument for methods such as assert.strictEqual(). expected <any> Set to the expected value for methods such as assert.strictEqual(). generatedMessage <boolean> Indicates if the message was auto-generated (true) or not. code <string> Value is always ERR_ASSERTION to show that the error is an assertion error. operator <string> Set to the passed in operator value. import assert from 'node:assert'; // Generate an AssertionError to compare the error message later: const { message } = new assert.AssertionError({ actual: 1, expected: 2, operator: 'strictEqual', }); // Verify error output: try { assert.strictEqual(1, 2); } catch (err) { assert(err instanceof assert.AssertionError); assert.strictEqual(err.message, message); assert.strictEqual(err.name, 'AssertionError'); assert.strictEqual(err.actual, 1); assert.strictEqual(err.expected, 2); assert.strictEqual(err.code, 'ERR_ASSERTION'); assert.strictEqual(err.operator, 'strictEqual'); assert.strictEqual(err.generatedMessage, true); }const assert = require('node:assert'); // Generate an AssertionError to compare the error message later: const { message } = new assert.AssertionError({ actual: 1, expected: 2, operator: 'strictEqual', }); // Verify error output: try { assert.strictEqual(1, 2); } catch (err) { assert(err instanceof assert.AssertionError); assert.strictEqual(err.message, message); assert.strictEqual(err.name, 'AssertionError'); assert.strictEqual(err.actual, 1); assert.strictEqual(err.expected, 2); assert.strictEqual(err.code, 'ERR_ASSERTION'); assert.strictEqual(err.operator, 'strictEqual'); assert.strictEqual(err.generatedMessage, true); }copy Class: assert.Assert# Added in: v24.6.0 The Assert class allows creating independent assertion instances with custom options. new assert.Assert([options])# options <Object> diff <string> If set to 'full', shows the full diff in assertion errors. Defaults to 'simple'. Accepted values: 'simple', 'full'. strict <boolean> If set to true, non-strict methods behave like their corresponding strict methods. Defaults to true. Creates a new assertion instance. The diff option controls the verbosity of diffs in assertion error messages. const { Assert } = require('node:assert'); const assertInstance = new Assert({ diff: 'full' }); assertInstance.deepStrictEqual({ a: 1 }, { a: 2 }); // Shows a full diff in the error message. copy Important: When destructuring assertion methods from an Assert instance, the methods lose their connection to the instance's configuration options (such as diff and strict settings). The destructured methods will fall back to default behavior instead. const myAssert = new Assert({ diff: 'full' }); // This works as expected - uses 'full' diff myAssert.strictEqual({ a: 1 }, { b: { c: 1 } }); // This loses the 'full' diff setting - falls back to default 'simple' diff const { strictEqual } = myAssert; strictEqual({ a: 1 }, { b: { c: 1 } }); copy When destructured, methods lose access to the instance's this context and revert to default assertion behavior (diff: 'simple', non-strict mode). To maintain custom options when using destructured methods, avoid destructuring and call methods directly on the instance. Class: assert.CallTracker# History VersionChanges v20.1.0 the assert.CallTracker class has been deprecated and will be removed in a future version. v14.2.0, v12.19.0 Added in: v14.2.0, v12.19.0 Stability: 0 - Deprecated This feature is deprecated and will be removed in a future version. Please consider using alternatives such as the mock helper function. new assert.CallTracker()# Added in: v14.2.0, v12.19.0 Creates a new CallTracker object which can be used to track if functions were called a specific number of times. The tracker.verify() must be called for the verification to take place. The usual pattern would be to call it in a process.on('exit') handler. import assert from 'node:assert'; import process from 'node:process'; const tracker = new assert.CallTracker(); function func() {} // callsfunc() must be called exactly 1 time before tracker.verify(). const callsfunc = tracker.calls(func, 1); callsfunc(); // Calls tracker.verify() and verifies if all tracker.calls() functions have // been called exact times. process.on('exit', () => { tracker.verify(); });const assert = require('node:assert'); const process = require('node:process'); const tracker = new assert.CallTracker(); function func() {} // callsfunc() must be called exactly 1 time before tracker.verify(). const callsfunc = tracker.calls(func, 1); callsfunc(); // Calls tracker.verify() and verifies if all tracker.calls() functions have // been called exact times. process.on('exit', () => { tracker.verify(); });copy tracker.calls([fn][, exact])# Added in: v14.2.0, v12.19.0 fn <Function> Default: A no-op function. exact <number> Default: 1. Returns: <Function> A function that wraps fn. The wrapper function is expected to be called exactly exact times. If the function has not been called exactly exact times when tracker.verify() is called, then tracker.verify() will throw an error. import assert from 'node:assert'; // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func);const assert = require('node:assert'); // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func);copy tracker.getCalls(fn)# Added in: v18.8.0, v16.18.0 fn <Function> Returns: <Array> An array with all the calls to a tracked function. Object <Object> thisArg <Object> arguments <Array> the arguments passed to the tracked function import assert from 'node:assert'; const tracker = new assert.CallTracker(); function func() {} const callsfunc = tracker.calls(func); callsfunc(1, 2, 3); assert.deepStrictEqual(tracker.getCalls(callsfunc), [{ thisArg: undefined, arguments: [1, 2, 3] }]);const assert = require('node:assert'); // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} const callsfunc = tracker.calls(func); callsfunc(1, 2, 3); assert.deepStrictEqual(tracker.getCalls(callsfunc), [{ thisArg: undefined, arguments: [1, 2, 3] }]);copy tracker.report()# Added in: v14.2.0, v12.19.0 Returns: <Array> An array of objects containing information about the wrapper functions returned by tracker.calls(). Object <Object> message <string> actual <number> The actual number of times the function was called. expected <number> The number of times the function was expected to be called. operator <string> The name of the function that is wrapped. stack <Object> A stack trace of the function. The arrays contains information about the expected and actual number of calls of the functions that have not been called the expected number of times. import assert from 'node:assert'; // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func, 2); // Returns an array containing information on callsfunc() console.log(tracker.report()); // [ // { // message: 'Expected the func function to be executed 2 time(s) but was // executed 0 time(s).', // actual: 0, // expected: 2, // operator: 'func', // stack: stack trace // } // ]const assert = require('node:assert'); // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func, 2); // Returns an array containing information on callsfunc() console.log(tracker.report()); // [ // { // message: 'Expected the func function to be executed 2 time(s) but was // executed 0 time(s).', // actual: 0, // expected: 2, // operator: 'func', // stack: stack trace // } // ]copy tracker.reset([fn])# Added in: v18.8.0, v16.18.0 fn <Function> a tracked function to reset. Reset calls of the call tracker. If a tracked function is passed as an argument, the calls will be reset for it. If no arguments are passed, all tracked functions will be reset. import assert from 'node:assert'; const tracker = new assert.CallTracker(); function func() {} const callsfunc = tracker.calls(func); callsfunc(); // Tracker was called once assert.strictEqual(tracker.getCalls(callsfunc).length, 1); tracker.reset(callsfunc); assert.strictEqual(tracker.getCalls(callsfunc).length, 0);const assert = require('node:assert'); const tracker = new assert.CallTracker(); function func() {} const callsfunc = tracker.calls(func); callsfunc(); // Tracker was called once assert.strictEqual(tracker.getCalls(callsfunc).length, 1); tracker.reset(callsfunc); assert.strictEqual(tracker.getCalls(callsfunc).length, 0);copy tracker.verify()# Added in: v14.2.0, v12.19.0 Iterates through the list of functions passed to tracker.calls() and will throw an error for functions that have not been called the expected number of times. import assert from 'node:assert'; // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func, 2); callsfunc(); // Will throw an error since callsfunc() was only called once. tracker.verify();const assert = require('node:assert'); // Creates call tracker. const tracker = new assert.CallTracker(); function func() {} // Returns a function that wraps func() that must be called exact times // before tracker.verify(). const callsfunc = tracker.calls(func, 2); callsfunc(); // Will throw an error since callsfunc() was only called once. tracker.verify();copy assert(value[, message])# Added in: v0.5.9 value <any> The input that is checked for being truthy. message <string> | <Error> An alias of assert.ok(). assert.deepEqual(actual, expected[, message])# History VersionChanges v24.0.0 Recursion now stops when either side encounters a circular reference. v22.2.0, v20.15.0 Error cause and errors properties are now compared as well. v18.0.0 Regular expressions lastIndex property is now compared as well. v16.0.0, v14.18.0 In Legacy assertion mode, changed status from Deprecated to Legacy. v14.0.0 NaN is now treated as being identical if both sides are NaN. v12.0.0 The type tags are now properly compared and there are a couple minor comparison adjustments to make the check less surprising. v9.0.0 The Error names and messages are now properly compared. v8.0.0 The Set and Map content is also compared. v6.4.0, v4.7.1 Typed array slices are handled correctly now. v6.1.0, v4.5.0 Objects with circular references can be used as inputs now. v5.10.1, v4.4.3 Handle non-Uint8Array typed arrays correctly. v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Strict assertion mode An alias of assert.deepStrictEqual(). Legacy assertion mode Stability: 3 - Legacy: Use assert.deepStrictEqual() instead. Tests for deep equality between the actual and expected parameters. Consider using assert.deepStrictEqual() instead. assert.deepEqual() can have surprising results. Deep equality means that the enumerable \"own\" properties of child objects are also recursively evaluated by the following rules. Comparison details# Primitive values are compared with the == operator, with the exception of <NaN>. It is treated as being identical in case both sides are <NaN>. Type tags of objects should be the same. Only enumerable \"own\" properties are considered. <Error> names, messages, causes, and errors are always compared, even if these are not enumerable properties. Object wrappers are compared both as objects and unwrapped values. Object properties are compared unordered. <Map> keys and <Set> items are compared unordered. Recursion stops when both sides differ or either side encounters a circular reference. Implementation does not test the [[Prototype]] of objects. <Symbol> properties are not compared. <WeakMap> and <WeakSet> comparison does not rely on their values but only on their instances. <RegExp> lastIndex, flags, and source are always compared, even if these are not enumerable properties. The following example does not throw an AssertionError because the primitives are compared using the == operator. import assert from 'node:assert'; // WARNING: This does not throw an AssertionError! assert.deepEqual('+00000000', false);const assert = require('node:assert'); // WARNING: This does not throw an AssertionError! assert.deepEqual('+00000000', false);copy \"Deep\" equality means that the enumerable \"own\" properties of child objects are evaluated also: import assert from 'node:assert'; const obj1 = { a: { b: 1, }, }; const obj2 = { a: { b: 2, }, }; const obj3 = { a: { b: 1, }, }; const obj4 = { __proto__: obj1 }; assert.deepEqual(obj1, obj1); // OK // Values of b are different: assert.deepEqual(obj1, obj2); // AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } } assert.deepEqual(obj1, obj3); // OK // Prototypes are ignored: assert.deepEqual(obj1, obj4); // AssertionError: { a: { b: 1 } } deepEqual {}const assert = require('node:assert'); const obj1 = { a: { b: 1, }, }; const obj2 = { a: { b: 2, }, }; const obj3 = { a: { b: 1, }, }; const obj4 = { __proto__: obj1 }; assert.deepEqual(obj1, obj1); // OK // Values of b are different: assert.deepEqual(obj1, obj2); // AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } } assert.deepEqual(obj1, obj3); // OK // Prototypes are ignored: assert.deepEqual(obj1, obj4); // AssertionError: { a: { b: 1 } } deepEqual {}copy If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.deepStrictEqual(actual, expected[, message])# History VersionChanges v24.0.0 Recursion now stops when either side encounters a circular reference. v22.2.0, v20.15.0 Error cause and errors properties are now compared as well. v18.0.0 Regular expressions lastIndex property is now compared as well. v9.0.0 Enumerable symbol properties are now compared. v9.0.0 The NaN is now compared using the SameValueZero comparison. v8.5.0 The Error names and messages are now properly compared. v8.0.0 The Set and Map content is also compared. v6.1.0 Objects with circular references can be used as inputs now. v6.4.0, v4.7.1 Typed array slices are handled correctly now. v5.10.1, v4.4.3 Handle non-Uint8Array typed arrays correctly. v1.2.0 Added in: v1.2.0 actual <any> expected <any> message <string> | <Error> Tests for deep equality between the actual and expected parameters. \"Deep\" equality means that the enumerable \"own\" properties of child objects are recursively evaluated also by the following rules. Comparison details# Primitive values are compared using Object.is(). Type tags of objects should be the same. [[Prototype]] of objects are compared using the === operator. Only enumerable \"own\" properties are considered. <Error> names, messages, causes, and errors are always compared, even if these are not enumerable properties. errors is also compared. Enumerable own <Symbol> properties are compared as well. Object wrappers are compared both as objects and unwrapped values. Object properties are compared unordered. <Map> keys and <Set> items are compared unordered. Recursion stops when both sides differ or either side encounters a circular reference. <WeakMap> and <WeakSet> instances are not compared structurally. They are only equal if they reference the same object. Any comparison between different WeakMap or WeakSet instances will result in inequality, even if they contain the same entries. <RegExp> lastIndex, flags, and source are always compared, even if these are not enumerable properties. import assert from 'node:assert/strict'; // This fails because 1 !== '1'. assert.deepStrictEqual({ a: 1 }, { a: '1' }); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // { // + a: 1 // - a: '1' // } // The following objects don't have own properties const date = new Date(); const object = {}; const fakeDate = {}; Object.setPrototypeOf(fakeDate, Date.prototype); // Different [[Prototype]]: assert.deepStrictEqual(object, fakeDate); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + {} // - Date {} // Different type tags: assert.deepStrictEqual(date, fakeDate); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + 2018-04-26T00:49:08.604Z // - Date {} assert.deepStrictEqual(NaN, NaN); // OK because Object.is(NaN, NaN) is true. // Different unwrapped numbers: assert.deepStrictEqual(new Number(1), new Number(2)); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + [Number: 1] // - [Number: 2] assert.deepStrictEqual(new String('foo'), Object('foo')); // OK because the object and the string are identical when unwrapped. assert.deepStrictEqual(-0, -0); // OK // Different zeros: assert.deepStrictEqual(0, -0); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + 0 // - -0 const symbol1 = Symbol(); const symbol2 = Symbol(); assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 }); // OK, because it is the same symbol on both objects. assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 }); // AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal: // // { // Symbol(): 1 // } const weakMap1 = new WeakMap(); const weakMap2 = new WeakMap(); const obj = {}; weakMap1.set(obj, 'value'); weakMap2.set(obj, 'value'); // Comparing different instances fails, even with same contents assert.deepStrictEqual(weakMap1, weakMap2); // AssertionError: Values have same structure but are not reference-equal: // // WeakMap { // <items unknown> // } // Comparing the same instance to itself succeeds assert.deepStrictEqual(weakMap1, weakMap1); // OK const weakSet1 = new WeakSet(); const weakSet2 = new WeakSet(); weakSet1.add(obj); weakSet2.add(obj); // Comparing different instances fails, even with same contents assert.deepStrictEqual(weakSet1, weakSet2); // AssertionError: Values have same structure but are not reference-equal: // + actual - expected // // WeakSet { // <items unknown> // } // Comparing the same instance to itself succeeds assert.deepStrictEqual(weakSet1, weakSet1); // OKconst assert = require('node:assert/strict'); // This fails because 1 !== '1'. assert.deepStrictEqual({ a: 1 }, { a: '1' }); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // { // + a: 1 // - a: '1' // } // The following objects don't have own properties const date = new Date(); const object = {}; const fakeDate = {}; Object.setPrototypeOf(fakeDate, Date.prototype); // Different [[Prototype]]: assert.deepStrictEqual(object, fakeDate); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + {} // - Date {} // Different type tags: assert.deepStrictEqual(date, fakeDate); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + 2018-04-26T00:49:08.604Z // - Date {} assert.deepStrictEqual(NaN, NaN); // OK because Object.is(NaN, NaN) is true. // Different unwrapped numbers: assert.deepStrictEqual(new Number(1), new Number(2)); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + [Number: 1] // - [Number: 2] assert.deepStrictEqual(new String('foo'), Object('foo')); // OK because the object and the string are identical when unwrapped. assert.deepStrictEqual(-0, -0); // OK // Different zeros: assert.deepStrictEqual(0, -0); // AssertionError: Expected inputs to be strictly deep-equal: // + actual - expected // // + 0 // - -0 const symbol1 = Symbol(); const symbol2 = Symbol(); assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 }); // OK, because it is the same symbol on both objects. assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 }); // AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal: // // { // Symbol(): 1 // } const weakMap1 = new WeakMap(); const weakMap2 = new WeakMap(); const obj = {}; weakMap1.set(obj, 'value'); weakMap2.set(obj, 'value'); // Comparing different instances fails, even with same contents assert.deepStrictEqual(weakMap1, weakMap2); // AssertionError: Values have same structure but are not reference-equal: // // WeakMap { // <items unknown> // } // Comparing the same instance to itself succeeds assert.deepStrictEqual(weakMap1, weakMap1); // OK const weakSet1 = new WeakSet(); const weakSet2 = new WeakSet(); weakSet1.add(obj); weakSet2.add(obj); // Comparing different instances fails, even with same contents assert.deepStrictEqual(weakSet1, weakSet2); // AssertionError: Values have same structure but are not reference-equal: // + actual - expected // // WeakSet { // <items unknown> // } // Comparing the same instance to itself succeeds assert.deepStrictEqual(weakSet1, weakSet1); // OKcopy If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.doesNotMatch(string, regexp[, message])# History VersionChanges v16.0.0 This API is no longer experimental. v13.6.0, v12.16.0 Added in: v13.6.0, v12.16.0 string <string> regexp <RegExp> message <string> | <Error> Expects the string input not to match the regular expression. import assert from 'node:assert/strict'; assert.doesNotMatch('I will fail', /fail/); // AssertionError [ERR_ASSERTION]: The input was expected to not match the ... assert.doesNotMatch(123, /pass/); // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string. assert.doesNotMatch('I will pass', /different/); // OKconst assert = require('node:assert/strict'); assert.doesNotMatch('I will fail', /fail/); // AssertionError [ERR_ASSERTION]: The input was expected to not match the ... assert.doesNotMatch(123, /pass/); // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string. assert.doesNotMatch('I will pass', /different/); // OKcopy If the values do match, or if the string argument is of another type than string, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.doesNotReject(asyncFn[, error][, message])# Added in: v10.0.0 asyncFn <Function> | <Promise> error <RegExp> | <Function> message <string> Returns: <Promise> Awaits the asyncFn promise or, if asyncFn is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected. If asyncFn is a function and it throws an error synchronously, assert.doesNotReject() will return a rejected Promise with that error. If the function does not return a promise, assert.doesNotReject() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped. Using assert.doesNotReject() is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible. If specified, error can be a Class, <RegExp> or a validation function. See assert.throws() for more details. Besides the async nature to await the completion behaves identically to assert.doesNotThrow(). import assert from 'node:assert/strict'; await assert.doesNotReject( async () => { throw new TypeError('Wrong value'); }, SyntaxError, );const assert = require('node:assert/strict'); (async () => { await assert.doesNotReject( async () => { throw new TypeError('Wrong value'); }, SyntaxError, ); })();copy import assert from 'node:assert/strict'; assert.doesNotReject(Promise.reject(new TypeError('Wrong value'))) .then(() => { // ... });const assert = require('node:assert/strict'); assert.doesNotReject(Promise.reject(new TypeError('Wrong value'))) .then(() => { // ... });copy assert.doesNotThrow(fn[, error][, message])# History VersionChanges v5.11.0, v4.4.5 The message parameter is respected now. v4.2.0 The error parameter can now be an arrow function. v0.1.21 Added in: v0.1.21 fn <Function> error <RegExp> | <Function> message <string> Asserts that the function fn does not throw an error. Using assert.doesNotThrow() is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible. When assert.doesNotThrow() is called, it will immediately call the fn function. If an error is thrown and it is the same type as that specified by the error parameter, then an AssertionError is thrown. If the error is of a different type, or if the error parameter is undefined, the error is propagated back to the caller. If specified, error can be a Class, <RegExp>, or a validation function. See assert.throws() for more details. The following, for instance, will throw the <TypeError> because there is no matching error type in the assertion: import assert from 'node:assert/strict'; assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, SyntaxError, );const assert = require('node:assert/strict'); assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, SyntaxError, );copy However, the following will result in an AssertionError with the message 'Got unwanted exception...': import assert from 'node:assert/strict'; assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, TypeError, );const assert = require('node:assert/strict'); assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, TypeError, );copy If an AssertionError is thrown and a value is provided for the message parameter, the value of message will be appended to the AssertionError message: import assert from 'node:assert/strict'; assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, /Wrong value/, 'Whoops', ); // Throws: AssertionError: Got unwanted exception: Whoopsconst assert = require('node:assert/strict'); assert.doesNotThrow( () => { throw new TypeError('Wrong value'); }, /Wrong value/, 'Whoops', ); // Throws: AssertionError: Got unwanted exception: Whoopscopy assert.equal(actual, expected[, message])# History VersionChanges v16.0.0, v14.18.0 In Legacy assertion mode, changed status from Deprecated to Legacy. v14.0.0 NaN is now treated as being identical if both sides are NaN. v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Strict assertion mode An alias of assert.strictEqual(). Legacy assertion mode Stability: 3 - Legacy: Use assert.strictEqual() instead. Tests shallow, coercive equality between the actual and expected parameters using the == operator. NaN is specially handled and treated as being identical if both sides are NaN. import assert from 'node:assert'; assert.equal(1, 1); // OK, 1 == 1 assert.equal(1, '1'); // OK, 1 == '1' assert.equal(NaN, NaN); // OK assert.equal(1, 2); // AssertionError: 1 == 2 assert.equal({ a: { b: 1 } }, { a: { b: 1 } }); // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }const assert = require('node:assert'); assert.equal(1, 1); // OK, 1 == 1 assert.equal(1, '1'); // OK, 1 == '1' assert.equal(NaN, NaN); // OK assert.equal(1, 2); // AssertionError: 1 == 2 assert.equal({ a: { b: 1 } }, { a: { b: 1 } }); // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }copy If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.fail([message])# Added in: v0.1.21 message <string> | <Error> Default: 'Failed' Throws an AssertionError with the provided error message or a default error message. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. import assert from 'node:assert/strict'; assert.fail(); // AssertionError [ERR_ASSERTION]: Failed assert.fail('boom'); // AssertionError [ERR_ASSERTION]: boom assert.fail(new TypeError('need array')); // TypeError: need arrayconst assert = require('node:assert/strict'); assert.fail(); // AssertionError [ERR_ASSERTION]: Failed assert.fail('boom'); // AssertionError [ERR_ASSERTION]: boom assert.fail(new TypeError('need array')); // TypeError: need arraycopy Using assert.fail() with more than two arguments is possible but deprecated. See below for further details. assert.fail(actual, expected[, message[, operator[, stackStartFn]]])# History VersionChanges v10.0.0 Calling assert.fail() with more than one argument is deprecated and emits a warning. v0.1.21 Added in: v0.1.21 Stability: 0 - Deprecated: Use assert.fail([message]) or other assert functions instead. actual <any> expected <any> message <string> | <Error> operator <string> Default: '!=' stackStartFn <Function> Default: assert.fail If message is falsy, the error message is set as the values of actual and expected separated by the provided operator. If just the two actual and expected arguments are provided, operator will default to '!='. If message is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If stackStartFn is provided, all stack frames above that function will be removed from stacktrace (see Error.captureStackTrace). If no arguments are given, the default message Failed will be used. import assert from 'node:assert/strict'; assert.fail('a', 'b'); // AssertionError [ERR_ASSERTION]: 'a' != 'b' assert.fail(1, 2, undefined, '>'); // AssertionError [ERR_ASSERTION]: 1 > 2 assert.fail(1, 2, 'fail'); // AssertionError [ERR_ASSERTION]: fail assert.fail(1, 2, 'whoops', '>'); // AssertionError [ERR_ASSERTION]: whoops assert.fail(1, 2, new TypeError('need array')); // TypeError: need arrayconst assert = require('node:assert/strict'); assert.fail('a', 'b'); // AssertionError [ERR_ASSERTION]: 'a' != 'b' assert.fail(1, 2, undefined, '>'); // AssertionError [ERR_ASSERTION]: 1 > 2 assert.fail(1, 2, 'fail'); // AssertionError [ERR_ASSERTION]: fail assert.fail(1, 2, 'whoops', '>'); // AssertionError [ERR_ASSERTION]: whoops assert.fail(1, 2, new TypeError('need array')); // TypeError: need arraycopy In the last three cases actual, expected, and operator have no influence on the error message. Example use of stackStartFn for truncating the exception's stacktrace: import assert from 'node:assert/strict'; function suppressFrame() { assert.fail('a', 'b', undefined, '!==', suppressFrame); } suppressFrame(); // AssertionError [ERR_ASSERTION]: 'a' !== 'b' // at repl:1:1 // at ContextifyScript.Script.runInThisContext (vm.js:44:33) // ...const assert = require('node:assert/strict'); function suppressFrame() { assert.fail('a', 'b', undefined, '!==', suppressFrame); } suppressFrame(); // AssertionError [ERR_ASSERTION]: 'a' !== 'b' // at repl:1:1 // at ContextifyScript.Script.runInThisContext (vm.js:44:33) // ...copy assert.ifError(value)# History VersionChanges v10.0.0 Instead of throwing the original error it is now wrapped into an [AssertionError][] that contains the full stack trace. v10.0.0 Value may now only be undefined or null. Before all falsy values were handled the same as null and did not throw. v0.1.97 Added in: v0.1.97 value <any> Throws value if value is not undefined or null. This is useful when testing the error argument in callbacks. The stack trace contains all frames from the error passed to ifError() including the potential new frames for ifError() itself. import assert from 'node:assert/strict'; assert.ifError(null); // OK assert.ifError(0); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0 assert.ifError('error'); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error' assert.ifError(new Error()); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error // Create some random error frames. let err; (function errorFrame() { err = new Error('test error'); })(); (function ifErrorFrame() { assert.ifError(err); })(); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error // at ifErrorFrame // at errorFrameconst assert = require('node:assert/strict'); assert.ifError(null); // OK assert.ifError(0); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0 assert.ifError('error'); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error' assert.ifError(new Error()); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error // Create some random error frames. let err; (function errorFrame() { err = new Error('test error'); })(); (function ifErrorFrame() { assert.ifError(err); })(); // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error // at ifErrorFrame // at errorFramecopy assert.match(string, regexp[, message])# History VersionChanges v16.0.0 This API is no longer experimental. v13.6.0, v12.16.0 Added in: v13.6.0, v12.16.0 string <string> regexp <RegExp> message <string> | <Error> Expects the string input to match the regular expression. import assert from 'node:assert/strict'; assert.match('I will fail', /pass/); // AssertionError [ERR_ASSERTION]: The input did not match the regular ... assert.match(123, /pass/); // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string. assert.match('I will pass', /pass/); // OKconst assert = require('node:assert/strict'); assert.match('I will fail', /pass/); // AssertionError [ERR_ASSERTION]: The input did not match the regular ... assert.match(123, /pass/); // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string. assert.match('I will pass', /pass/); // OKcopy If the values do not match, or if the string argument is of another type than string, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.notDeepEqual(actual, expected[, message])# History VersionChanges v16.0.0, v14.18.0 In Legacy assertion mode, changed status from Deprecated to Legacy. v14.0.0 NaN is now treated as being identical if both sides are NaN. v9.0.0 The Error names and messages are now properly compared. v8.0.0 The Set and Map content is also compared. v6.4.0, v4.7.1 Typed array slices are handled correctly now. v6.1.0, v4.5.0 Objects with circular references can be used as inputs now. v5.10.1, v4.4.3 Handle non-Uint8Array typed arrays correctly. v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Strict assertion mode An alias of assert.notDeepStrictEqual(). Legacy assertion mode Stability: 3 - Legacy: Use assert.notDeepStrictEqual() instead. Tests for any deep inequality. Opposite of assert.deepEqual(). import assert from 'node:assert'; const obj1 = { a: { b: 1, }, }; const obj2 = { a: { b: 2, }, }; const obj3 = { a: { b: 1, }, }; const obj4 = { __proto__: obj1 }; assert.notDeepEqual(obj1, obj1); // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } } assert.notDeepEqual(obj1, obj2); // OK assert.notDeepEqual(obj1, obj3); // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } } assert.notDeepEqual(obj1, obj4); // OKconst assert = require('node:assert'); const obj1 = { a: { b: 1, }, }; const obj2 = { a: { b: 2, }, }; const obj3 = { a: { b: 1, }, }; const obj4 = { __proto__: obj1 }; assert.notDeepEqual(obj1, obj1); // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } } assert.notDeepEqual(obj1, obj2); // OK assert.notDeepEqual(obj1, obj3); // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } } assert.notDeepEqual(obj1, obj4); // OKcopy If the values are deeply equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.notDeepStrictEqual(actual, expected[, message])# History VersionChanges v9.0.0 The -0 and +0 are not considered equal anymore. v9.0.0 The NaN is now compared using the SameValueZero comparison. v9.0.0 The Error names and messages are now properly compared. v8.0.0 The Set and Map content is also compared. v6.1.0 Objects with circular references can be used as inputs now. v6.4.0, v4.7.1 Typed array slices are handled correctly now. v5.10.1, v4.4.3 Handle non-Uint8Array typed arrays correctly. v1.2.0 Added in: v1.2.0 actual <any> expected <any> message <string> | <Error> Tests for deep strict inequality. Opposite of assert.deepStrictEqual(). import assert from 'node:assert/strict'; assert.notDeepStrictEqual({ a: 1 }, { a: '1' }); // OKconst assert = require('node:assert/strict'); assert.notDeepStrictEqual({ a: 1 }, { a: '1' }); // OKcopy If the values are deeply and strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.notEqual(actual, expected[, message])# History VersionChanges v16.0.0, v14.18.0 In Legacy assertion mode, changed status from Deprecated to Legacy. v14.0.0 NaN is now treated as being identical if both sides are NaN. v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Strict assertion mode An alias of assert.notStrictEqual(). Legacy assertion mode Stability: 3 - Legacy: Use assert.notStrictEqual() instead. Tests shallow, coercive inequality with the != operator. NaN is specially handled and treated as being identical if both sides are NaN. import assert from 'node:assert'; assert.notEqual(1, 2); // OK assert.notEqual(1, 1); // AssertionError: 1 != 1 assert.notEqual(1, '1'); // AssertionError: 1 != '1'const assert = require('node:assert'); assert.notEqual(1, 2); // OK assert.notEqual(1, 1); // AssertionError: 1 != 1 assert.notEqual(1, '1'); // AssertionError: 1 != '1'copy If the values are equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.notStrictEqual(actual, expected[, message])# History VersionChanges v10.0.0 Used comparison changed from Strict Equality to Object.is(). v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Tests strict inequality between the actual and expected parameters as determined by Object.is(). import assert from 'node:assert/strict'; assert.notStrictEqual(1, 2); // OK assert.notStrictEqual(1, 1); // AssertionError [ERR_ASSERTION]: Expected \"actual\" to be strictly unequal to: // // 1 assert.notStrictEqual(1, '1'); // OKconst assert = require('node:assert/strict'); assert.notStrictEqual(1, 2); // OK assert.notStrictEqual(1, 1); // AssertionError [ERR_ASSERTION]: Expected \"actual\" to be strictly unequal to: // // 1 assert.notStrictEqual(1, '1'); // OKcopy If the values are strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.ok(value[, message])# History VersionChanges v10.0.0 The assert.ok() (no arguments) will now use a predefined error message. v0.1.21 Added in: v0.1.21 value <any> message <string> | <Error> Tests if value is truthy. It is equivalent to assert.equal(!!value, true, message). If value is not truthy, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. If no arguments are passed in at all message will be set to the string: 'No value argument passed to `assert.ok()`'. Be aware that in the repl the error message will be different to the one thrown in a file! See below for further details. import assert from 'node:assert/strict'; assert.ok(true); // OK assert.ok(1); // OK assert.ok(); // AssertionError: No value argument passed to `assert.ok()` assert.ok(false, 'it\\'s false'); // AssertionError: it's false // In the repl: assert.ok(typeof 123 === 'string'); // AssertionError: false == true // In a file (e.g. test.js): assert.ok(typeof 123 === 'string'); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(typeof 123 === 'string') assert.ok(false); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(false) assert.ok(0); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(0)const assert = require('node:assert/strict'); assert.ok(true); // OK assert.ok(1); // OK assert.ok(); // AssertionError: No value argument passed to `assert.ok()` assert.ok(false, 'it\\'s false'); // AssertionError: it's false // In the repl: assert.ok(typeof 123 === 'string'); // AssertionError: false == true // In a file (e.g. test.js): assert.ok(typeof 123 === 'string'); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(typeof 123 === 'string') assert.ok(false); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(false) assert.ok(0); // AssertionError: The expression evaluated to a falsy value: // // assert.ok(0)copy import assert from 'node:assert/strict'; // Using `assert()` works the same: assert(0); // AssertionError: The expression evaluated to a falsy value: // // assert(0)const assert = require('node:assert'); // Using `assert()` works the same: assert(0); // AssertionError: The expression evaluated to a falsy value: // // assert(0)copy assert.rejects(asyncFn[, error][, message])# Added in: v10.0.0 asyncFn <Function> | <Promise> error <RegExp> | <Function> | <Object> | <Error> message <string> Returns: <Promise> Awaits the asyncFn promise or, if asyncFn is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected. If asyncFn is a function and it throws an error synchronously, assert.rejects() will return a rejected Promise with that error. If the function does not return a promise, assert.rejects() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped. Besides the async nature to await the completion behaves identically to assert.throws(). If specified, error can be a Class, <RegExp>, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable message and name properties. If specified, message will be the message provided by the AssertionError if the asyncFn fails to reject. import assert from 'node:assert/strict'; await assert.rejects( async () => { throw new TypeError('Wrong value'); }, { name: 'TypeError', message: 'Wrong value', }, );const assert = require('node:assert/strict'); (async () => { await assert.rejects( async () => { throw new TypeError('Wrong value'); }, { name: 'TypeError', message: 'Wrong value', }, ); })();copy import assert from 'node:assert/strict'; await assert.rejects( async () => { throw new TypeError('Wrong value'); }, (err) => { assert.strictEqual(err.name, 'TypeError'); assert.strictEqual(err.message, 'Wrong value'); return true; }, );const assert = require('node:assert/strict'); (async () => { await assert.rejects( async () => { throw new TypeError('Wrong value'); }, (err) => { assert.strictEqual(err.name, 'TypeError'); assert.strictEqual(err.message, 'Wrong value'); return true; }, ); })();copy import assert from 'node:assert/strict'; assert.rejects( Promise.reject(new Error('Wrong value')), Error, ).then(() => { // ... });const assert = require('node:assert/strict'); assert.rejects( Promise.reject(new Error('Wrong value')), Error, ).then(() => { // ... });copy error cannot be a string. If a string is provided as the second argument, then error is assumed to be omitted and the string will be used for message instead. This can lead to easy-to-miss mistakes. Please read the example in assert.throws() carefully if using a string as the second argument gets considered. assert.strictEqual(actual, expected[, message])# History VersionChanges v10.0.0 Used comparison changed from Strict Equality to Object.is(). v0.1.21 Added in: v0.1.21 actual <any> expected <any> message <string> | <Error> Tests strict equality between the actual and expected parameters as determined by Object.is(). import assert from 'node:assert/strict'; assert.strictEqual(1, 2); // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: // // 1 !== 2 assert.strictEqual(1, 1); // OK assert.strictEqual('Hello foobar', 'Hello World!'); // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: // + actual - expected // // + 'Hello foobar' // - 'Hello World!' // ^ const apples = 1; const oranges = 2; assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`); // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2 assert.strictEqual(1, '1', new TypeError('Inputs are not identical')); // TypeError: Inputs are not identicalconst assert = require('node:assert/strict'); assert.strictEqual(1, 2); // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: // // 1 !== 2 assert.strictEqual(1, 1); // OK assert.strictEqual('Hello foobar', 'Hello World!'); // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: // + actual - expected // // + 'Hello foobar' // - 'Hello World!' // ^ const apples = 1; const oranges = 2; assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`); // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2 assert.strictEqual(1, '1', new TypeError('Inputs are not identical')); // TypeError: Inputs are not identicalcopy If the values are not strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. assert.throws(fn[, error][, message])# History VersionChanges v10.2.0 The error parameter can be an object containing regular expressions now. v9.9.0 The error parameter can now be an object as well. v4.2.0 The error parameter can now be an arrow function. v0.1.21 Added in: v0.1.21 fn <Function> error <RegExp> | <Function> | <Object> | <Error> message <string> Expects the function fn to throw an error. If specified, error can be a Class, <RegExp>, a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable message and name properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples. If specified, message will be appended to the message provided by the AssertionError if the fn call fails to throw or in case the error validation fails. Custom validation object/error instance: import assert from 'node:assert/strict'; const err = new TypeError('Wrong value'); err.code = 404; err.foo = 'bar'; err.info = { nested: true, baz: 'text', }; err.reg = /abc/i; assert.throws( () => { throw err; }, { name: 'TypeError', message: 'Wrong value', info: { nested: true, baz: 'text', }, // Only properties on the validation object will be tested for. // Using nested objects requires all properties to be present. Otherwise // the validation is going to fail. }, ); // Using regular expressions to validate error properties: assert.throws( () => { throw err; }, { // The `name` and `message` properties are strings and using regular // expressions on those will match against the string. If they fail, an // error is thrown. name: /^TypeError$/, message: /Wrong/, foo: 'bar', info: { nested: true, // It is not possible to use regular expressions for nested properties! baz: 'text', }, // The `reg` property contains a regular expression and only if the // validation object contains an identical regular expression, it is going // to pass. reg: /abc/i, }, ); // Fails due to the different `message` and `name` properties: assert.throws( () => { const otherErr = new Error('Not found'); // Copy all enumerable properties from `err` to `otherErr`. for (const [key, value] of Object.entries(err)) { otherErr[key] = value; } throw otherErr; }, // The error's `message` and `name` properties will also be checked when using // an error as validation object. err, );const assert = require('node:assert/strict'); const err = new TypeError('Wrong value'); err.code = 404; err.foo = 'bar'; err.info = { nested: true, baz: 'text', }; err.reg = /abc/i; assert.throws( () => { throw err; }, { name: 'TypeError', message: 'Wrong value', info: { nested: true, baz: 'text', }, // Only properties on the validation object will be tested for. // Using nested objects requires all properties to be present. Otherwise // the validation is going to fail. }, ); // Using regular expressions to validate error properties: assert.throws( () => { throw err; }, { // The `name` and `message` properties are strings and using regular // expressions on those will match against the string. If they fail, an // error is thrown. name: /^TypeError$/, message: /Wrong/, foo: 'bar', info: { nested: true, // It is not possible to use regular expressions for nested properties! baz: 'text', }, // The `reg` property contains a regular expression and only if the // validation object contains an identical regular expression, it is going // to pass. reg: /abc/i, }, ); // Fails due to the different `message` and `name` properties: assert.throws( () => { const otherErr = new Error('Not found'); // Copy all enumerable properties from `err` to `otherErr`. for (const [key, value] of Object.entries(err)) { otherErr[key] = value; } throw otherErr; }, // The error's `message` and `name` properties will also be checked when using // an error as validation object. err, );copy Validate instanceof using constructor: import assert from 'node:assert/strict'; assert.throws( () => { throw new Error('Wrong value'); }, Error, );const assert = require('node:assert/strict'); assert.throws( () => { throw new Error('Wrong value'); }, Error, );copy Validate error message using <RegExp>: Using a regular expression runs .toString on the error object, and will therefore also include the error name. import assert from 'node:assert/strict'; assert.throws( () => { throw new Error('Wrong value'); }, /^Error: Wrong value$/, );const assert = require('node:assert/strict'); assert.throws( () => { throw new Error('Wrong value'); }, /^Error: Wrong value$/, );copy Custom error validation: The function must return true to indicate all internal validations passed. It will otherwise fail with an AssertionError. import assert from 'node:assert/strict'; assert.throws( () => { throw new Error('Wrong value'); }, (err) => { assert(err instanceof Error); assert(/value/.test(err)); // Avoid returning anything from validation functions besides `true`. // Otherwise, it's not clear what part of the validation failed. Instead, // throw an error about the specific validation that failed (as done in this // example) and add as much helpful debugging information to that error as // possible. return true; }, 'unexpected error', );const assert = require('node:assert/strict'); assert.throws( () => { throw new Error('Wrong value'); }, (err) => { assert(err instanceof Error); assert(/value/.test(err)); // Avoid returning anything from validation functions besides `true`. // Otherwise, it's not clear what part of the validation failed. Instead, // throw an error about the specific validation that failed (as done in this // example) and add as much helpful debugging information to that error as // possible. return true; }, 'unexpected error', );copy error cannot be a string. If a string is provided as the second argument, then error is assumed to be omitted and the string will be used for message instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an ERR_AMBIGUOUS_ARGUMENT error. Please read the example below carefully if using a string as the second argument gets considered: import assert from 'node:assert/strict'; function throwingFirst() { throw new Error('First'); } function throwingSecond() { throw new Error('Second'); } function notThrowing() {} // The second argument is a string and the input function threw an Error. // The first case will not throw as it does not match for the error message // thrown by the input function! assert.throws(throwingFirst, 'Second'); // In the next example the message has no benefit over the message from the // error and since it is not clear if the user intended to actually match // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error. assert.throws(throwingSecond, 'Second'); // TypeError [ERR_AMBIGUOUS_ARGUMENT] // The string is only used (as message) in case the function does not throw: assert.throws(notThrowing, 'Second'); // AssertionError [ERR_ASSERTION]: Missing expected exception: Second // If it was intended to match for the error message do this instead: // It does not throw because the error messages match. assert.throws(throwingSecond, /Second$/); // If the error message does not match, an AssertionError is thrown. assert.throws(throwingFirst, /Second$/); // AssertionError [ERR_ASSERTION]const assert = require('node:assert/strict'); function throwingFirst() { throw new Error('First'); } function throwingSecond() { throw new Error('Second'); } function notThrowing() {} // The second argument is a string and the input function threw an Error. // The first case will not throw as it does not match for the error message // thrown by the input function! assert.throws(throwingFirst, 'Second'); // In the next example the message has no benefit over the message from the // error and since it is not clear if the user intended to actually match // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error. assert.throws(throwingSecond, 'Second'); // TypeError [ERR_AMBIGUOUS_ARGUMENT] // The string is only used (as message) in case the function does not throw: assert.throws(notThrowing, 'Second'); // AssertionError [ERR_ASSERTION]: Missing expected exception: Second // If it was intended to match for the error message do this instead: // It does not throw because the error messages match. assert.throws(throwingSecond, /Second$/); // If the error message does not match, an AssertionError is thrown. assert.throws(throwingFirst, /Second$/); // AssertionError [ERR_ASSERTION]copy Due to the confusing error-prone notation, avoid a string as the second argument. assert.partialDeepStrictEqual(actual, expected[, message])# History VersionChanges v24.0.0 partialDeepStrictEqual is now Stable. Previously, it had been Experimental. v23.4.0, v22.13.0 Added in: v23.4.0, v22.13.0 actual <any> expected <any> message <string> | <Error> Tests for partial deep equality between the actual and expected parameters. \"Deep\" equality means that the enumerable \"own\" properties of child objects are recursively evaluated also by the following rules. \"Partial\" equality means that only properties that exist on the expected parameter are going to be compared. This method always passes the same test cases as assert.deepStrictEqual(), behaving as a super set of it. Comparison details# Primitive values are compared using Object.is(). Type tags of objects should be the same. [[Prototype]] of objects are not compared. Only enumerable \"own\" properties are considered. <Error> names, messages, causes, and errors are always compared, even if these are not enumerable properties. errors is also compared. Enumerable own <Symbol> properties are compared as well. Object wrappers are compared both as objects and unwrapped values. Object properties are compared unordered. <Map> keys and <Set> items are compared unordered. Recursion stops when both sides differ or both sides encounter a circular reference. <WeakMap> and <WeakSet> instances are not compared structurally. They are only equal if they reference the same object. Any comparison between different WeakMap or WeakSet instances will result in inequality, even if they contain the same entries. <RegExp> lastIndex, flags, and source are always compared, even if these are not enumerable properties. Holes in sparse arrays are ignored. import assert from 'node:assert'; assert.partialDeepStrictEqual( { a: { b: { c: 1 } } }, { a: { b: { c: 1 } } }, ); // OK assert.partialDeepStrictEqual( { a: 1, b: 2, c: 3 }, { b: 2 }, ); // OK assert.partialDeepStrictEqual( [1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 5, 8], ); // OK assert.partialDeepStrictEqual( new Set([{ a: 1 }, { b: 1 }]), new Set([{ a: 1 }]), ); // OK assert.partialDeepStrictEqual( new Map([['key1', 'value1'], ['key2', 'value2']]), new Map([['key2', 'value2']]), ); // OK assert.partialDeepStrictEqual(123n, 123n); // OK assert.partialDeepStrictEqual( [1, 2, 3, 4, 5, 6, 7, 8, 9], [5, 4, 8], ); // AssertionError assert.partialDeepStrictEqual( { a: 1 }, { a: 1, b: 2 }, ); // AssertionError assert.partialDeepStrictEqual( { a: { b: 2 } }, { a: { b: '2' } }, ); // AssertionErrorconst assert = require('node:assert'); assert.partialDeepStrictEqual( { a: { b: { c: 1 } } }, { a: { b: { c: 1 } } }, ); // OK assert.partialDeepStrictEqual( { a: 1, b: 2, c: 3 }, { b: 2 }, ); // OK assert.partialDeepStrictEqual( [1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 5, 8], ); // OK assert.partialDeepStrictEqual( new Set([{ a: 1 }, { b: 1 }]), new Set([{ a: 1 }]), ); // OK assert.partialDeepStrictEqual( new Map([['key1', 'value1'], ['key2', 'value2']]), new Map([['key2', 'value2']]), ); // OK assert.partialDeepStrictEqual(123n, 123n); // OK assert.partialDeepStrictEqual( [1, 2, 3, 4, 5, 6, 7, 8, 9], [5, 4, 8], ); // AssertionError assert.partialDeepStrictEqual( { a: 1 }, { a: 1, b: 2 }, ); // AssertionError assert.partialDeepStrictEqual( { a: { b: 2 } }, { a: { b: '2' } }, ); // AssertionErrorcopy",
    "word_count": 9220
  },
  "summary": {
    "summary": "expected <any> The expected property on the error instance. code <string> Value is always ERR_ASSERTION to show that the error is an assertion error. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of <Error> then it will be thrown instead of the AssertionError. v4.2.0 The error parameter can now be an arrow function. If an error is thrown and it is the same type as that specified by the error parameter, then an AssertionError is thrown. If the error is of a different type, or if the error parameter is undefined, the error is propagated back to the caller. assert.fail([message])# Added in: v0.1.21 message <string> | <Error> Default: 'Failed' Throws an AssertionError with the provided error message or a default error message. If message is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If value is not truthy, an AssertionError is thrown with a message property set equal to the value of the message parameter. If specified, message will be the message provided by the AssertionError if the asyncFn fails to reject. If specified, message will be appended to the message provided by the AssertionError if the fn call fails to throw or in case the error validation fails. Using the same message as the thrown error message is going to result in an ERR_AMBIGUOUS_ARGUMENT error.",
    "key_concepts": [
      "Assert",
      "Err",
      "Error",
      "Equal",
      "Assertion",
      "Strict",
      "Message",
      "Func",
      "One",
      "Throw",
      "Assertionerror",
      "Obj"
    ],
    "method": "nltk_extractive"
  },
  "mind_maps": {
    "visual": "\n                     \n                       ASSERT | NODE.JS V24.6.0 DOCUMENTATION  \n                     \n\n                                        \n                                   \n                                              \n  Assert                                              Message \n  Err                                                    Func \n  Error                                                   One \n  Equal                                                 Throw \n  Assertion                                    Assertionerror \n  Strict                                                  Obj \n\n\n                                   SUMMARY                                    \n\n expected <any> The expected property on the error instance. code <string>   \n Value is always ERR_ASSERTION to show that the error is an assertion        \n error. If the message parameter is undefined, a default error message is    \n assigned. If the message parameter is an instance of <Error> then it will   \n be thrown instead of the AssertionError. v4.2.0 The error parameter can     \n now be an arrow function. If an error is thrown and it is the same type as  \n that specified by the error parameter, then an AssertionError is thrown.    \n If the error is of a different type, or if the error parameter is           \n undefined, the error is propagated back to the caller.                      \n assert.fail([message])# Added in: v0.1.21 message <string> | <Error>        \n Default: 'Failed' Throws an AssertionError with the provided error message  \n or a default error message. If message is provided as third argument it     \n will be used as the error message and the other arguments will be stored    \n as properties on the thrown object. If value is not truthy, an              \n AssertionError is thrown with a message property set equal to the value of  \n the message parameter. If specified, message will be the message provided   \n by the AssertionError if the asyncFn fails to reject. If specified,         \n message will be appended to the message provided by the AssertionError if   \n the fn call fails to throw or in case the error validation fails. Using     \n the same message as the thrown error message is going to result in an       \n ERR_AMBIGUOUS_ARGUMENT error.                                               \n",
    "network": "\n\n                      NETWORK MIND MAP                      \n\n           Assert | Node.js v24.6.0 Documentation           \n\n\n         Assert | Node.js v24.6.0 Documentation\n        \n   \n            \n     Assert\n              Err\n            \n     Error\n              Equal\n            \n     Assertion\n              Strict\n            \n     Message\n              Func\n   \n     ... and more concepts",
    "hierarchical": "\n ASSERT | NODE.JS V24.6.0 DOCUMENTATION\n\n  Assert\n  Err\n  Error\n  Equal\n  Assertion\n  Strict\n  Message\n  Func\n  One\n  Throw\n  Assertionerror\n  Obj"
  }
}